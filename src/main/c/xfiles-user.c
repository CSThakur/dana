#include "xfiles.h"

// All RoCC communication occurs using the "custom0" RISC-V
// instruction of the following format:
//
//   custom0 <output register> <input reg 1> <input reg 2> <funct>
//
// The X-Files arbiter uses the bits of the 7-bit "funct" field to
// decode the instruction and figure out what it should do with it.
// The input registers are referred to as rs1 and rs2 in the
// rocket-chip repo and by available RoCC documentation so we stick
// with that convention below.
//
// The bits of "funct" are as follows:
//
//   |       [6:3]|       2|      1|            0|
//   | **unused** | isLast | isNew | readOrWrite |

tid_type new_write_request(nnid_type nnid, int learning_type,
                           element_type num_train_outputs) {
  uint64_t out, rs2;

  rs2 = (uint64_t) nnid |
    ((uint64_t) num_train_outputs << 32) |
    ((uint64_t) learning_type << 48);

  // Initiate a new transaction by setting the "readOrWrite" (bit 0,
  // read == 0 / write == 1) and "isNew" (bit 1) flags of "funct",
  // i.e., funct == 3. The nnid goes in rs2. The output will show up
  // in the varaible "out".
  asm volatile ("custom0 %[out], %[rs1], %[rs2], 3"
                : [out] "=r" (out)
                : [rs1] "r" (0), [rs2] "r" (rs2));

  // The TID is in bits [47:32] of what we get back. Pull out this
  // portion and return it. [TODO] This is fragile on tid and element
  // sizing.
  return (out >> 32) & ~((~0) << 16);
}

void write_data(tid_type tid, element_type * data, size_t count) {
  int i;

  // There are two types of writes available to users determined by
  // whether or not "isLast" (bit 2) is set. We write all but the last
  // data value with "isLast" deasserted (funct == 1). The tid goes in
  // rs1 and data goes in rs2.
  for (i = 0; i < count - 1; i++)
    asm volatile ("custom0 0, %[rs1], %[rs2], 1"
                  :: [rs1] "r" (tid), [rs2] "r" (data[i]));

  // Finally, we write the last data value with "isLast" set (funct ==
  // 5). When the X-Files Arbiter sees this "isLast" bit, it enables
  // execution of the transaction.
  asm volatile ("custom0 0, %[rs1], %[rs2], 5"
                :: [rs1] "r" (tid), [rs2] "r" (data[i]));
}

void write_data_train_incremental(tid_type tid, element_type * input,
                                  element_type * output, size_t count_input,
                                  size_t count_output) {
  // Simply write the exepcted outputs followed by the inputs.
  write_data(tid, output, count_output);
  write_data(tid, input, count_input);
}

uint64_t read_data_spinlock(tid_type tid, element_type * data, size_t count) {
  int i;
  uint64_t out;

  // A read request is generated by deasserting "readOrWrite" (funt ==
  // 0). The returned value includes some information in the two MSBs
  // about the type of data returned:
  //   0: This is a TID response to a new_write_request (should never
  //      occur)
  //   1: The read was on a done transaction and valid data was
  //      returned
  //   2: The transaction is not done (the LSBs contain some
  //      likely-to-be-changed, undocumented state information which
  //      can be used for debugging)
  // We then naively spinlock until we get some valid data.
  while (1) {
    asm volatile ("custom0 %[out], %[rs1], 0, 0"
                  : [out] "=r" (out)
                  : [rs1] "r" (tid));
    switch (out >> (32 + 16 + 14)) {
    case 2:  continue;
    case 1:  goto success;
    default: return -1;
    }
  }

  // Our successful read has valid data, so we store that in the first
  // entry of the output array.
 success:
  data[0] = out;

  // All following reads are guaranteed to have valid data, so we read
  // until the output array is full. The X-Files Arbiter invalidates
  // our transaction once all data values have been read, hence, there
  // is no need for setting the "isLast" bit.
  for (i = 1; i < count; i++)
    asm volatile ("custom0 %[out], %[rs1], 0, 0"
                  : [out] "=r" (data[i])
                  : [rs1] "r" (tid));
  return 0;
}
