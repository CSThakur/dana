// See LICENSE for license details.

#include "xfiles.h"

// All RoCC communication occurs using the "custom0" RISC-V
// instruction of the following format:
//
//   custom0 <output register> <input reg 1> <input reg 2> <funct>
//
// The X-Files arbiter uses the bits of the 7-bit "funct" field to
// decode the instruction and figure out what it should do with it.
// The input registers are referred to as rs1 and rs2 in the
// rocket-chip repo and by available RoCC documentation so we stick
// with that convention below.
//
// The bits of "funct" are as follows:
//
//   |       [6:3]|       2|      1|            0|
//   | **unused** | isLast | isNew | readOrWrite |

xlen_t xfiles_dana_id(int flag_print) {
  xlen_t out;

  asm volatile ("custom0 %[out], 0, 0, %[type]"
                : [out] "=r" (out)
                : [type] "i" (XFILES_DANA_ID));

  if (flag_print) {
    uint32_t elements_per_block = (out >> 14) & ~((~0) << 6);
    uint32_t pe_table_num_entries = (out >> 8) & ~((~0) << 6);
    uint32_t transaction_table_num_entries = (out >> 4) & ~((~0) << 4);
    uint32_t cache_num_entries = out & ~((~0) << 4);
    printf("X-FILES/DANA Info:\n"
           "  Elements per Block:        %d\n"
           "  PEs:                       %d\n"
           "  Transaction Table Entries: %d\n"
           "  Cache Entries:             %d\n",
           elements_per_block, pe_table_num_entries,
           transaction_table_num_entries, cache_num_entries);
  }

  return out;
}

tid_type new_write_request(nnid_type nnid, learning_type_t learning_type,
                           element_type num_train_outputs) {
  uint64_t out, rs2;

  rs2 = (uint64_t) nnid |
    ((uint64_t) num_train_outputs << 32) |
    ((uint64_t) learning_type << 48);

  // Initiate a new transaction by setting the "readOrWrite" (bit 0,
  // read == 0 / write == 1) and "isNew" (bit 1) flags of "funct",
  // i.e., funct == 3. The nnid goes in rs2. The output will show up
  // in the varaible "out".
  asm volatile ("custom0 %[out], %[rs1], %[rs2], %[type]"
                : [out] "=r" (out)
                : [rs1] "r" (0), [rs2] "r" (rs2), [type] "i" (NEW_REQUEST));

  // The TID is in bits [47:32] of what we get back. Pull out this
  // portion and return it. [TODO] This is fragile on tid and element
  // sizing.
  const size_t shift = sizeof(xlen_t)*8 - sizeof(tid_type)*8 - RESP_CODE_WIDTH;
  const xlen_t mask = (~((~(xlen_t)0) << 16)) << shift;
  return (out & mask) >> shift;
}

xlen_t write_register(tid_type tid, xfiles_reg reg, uint32_t value) {

  xlen_t rs2, out;
  rs2 = (uint64_t) value | ((uint64_t) reg << 32);

  asm volatile ("custom0 %[out], %[rs1], %[rs2], %[type]"
                : [out] "=r" (out)
                : [rs1] "r" (tid), [rs2] "r" (rs2),
                 [type] "i" (WRITE_REGISTER));
  return out;
}

xlen_t write_data(tid_type tid, element_type * data, size_t count) {
  int i;
  xlen_t out;

  // There are two types of writes available to users determined by
  // whether or not "isLast" (bit 2) is set. We write all but the last
  // data value with "isLast" deasserted (funct == 1). The tid goes in
  // rs1 and data goes in rs2.
  for (i = 0; i < count - 1; i++) {
    asm volatile ("custom0 %[out], %[rs1], %[rs2], %[type]"
                  : [out] "=r" (out)
                  : [rs1] "r" (tid), [rs2] "r" (data[i]),
                   [type] "i" (WRITE_DATA));
    if (out)
      return out;
  }


  // Finally, we write the last data value with "isLast" set (funct ==
  // 5). When the X-Files Arbiter sees this "isLast" bit, it enables
  // execution of the transaction.
  asm volatile ("custom0 %[out], %[rs1], %[rs2], %[type]"
                : [out] "=r" (out)
                : [rs1] "r" (tid), [rs2] "r" (data[i]),
                 [type] "i" (WRITE_DATA_LAST));
  return out;
}

xlen_t write_data_train_incremental(tid_type tid, element_type * input,
                                    element_type * output, size_t count_input,
                                    size_t count_output) {
  // Simply write the exepcted outputs followed by the inputs.
  xlen_t out = 0;
  if ((out = write_data(tid, output, count_output))) return out;
  if ((out = write_data(tid, input, count_input))) return out;
  return 0;
}

xlen_t read_data_spinlock(tid_type tid, element_type * data, size_t count) {
  int i;
  uint64_t out;

  // A read request is generated by deasserting "readOrWrite" (funt ==
  // 0). The returned value includes some information in the two MSBs
  // about the type of data returned:
  //   0: This is a TID response to a new_write_request (should never
  //      occur)
  //   1: The read was on a done transaction and valid data was
  //      returned
  //   2: The transaction is not done (the LSBs contain some
  //      likely-to-be-changed, undocumented state information which
  //      can be used for debugging)
  // We then naively spinlock until we get some valid data.
  while (1) {
    asm volatile ("custom0 %[out], %[rs1], 0, %[type]"
                  : [out] "=r" (out)
                  : [rs1] "r" (tid), [type] "i" (READ_DATA));
    switch (out >> (32 + 16 + 16 - RESP_CODE_WIDTH)) {
    case resp_NOT_DONE:  continue;
    case resp_OK:  goto success;
    default: return -1;
    }
  }

  // Our successful read has valid data, so we store that in the first
  // entry of the output array.
 success:
  data[0] = out;

  // All following reads are guaranteed to have valid data, so we read
  // until the output array is full. The X-Files Arbiter invalidates
  // our transaction once all data values have been read, hence, there
  // is no need for setting the "isLast" bit.
  for (i = 1; i < count; i++)
    asm volatile ("custom0 %[out], %[rs1], 0, %[type]"
                  : [out] "=r" (data[i])
                  : [rs1] "r" (tid), [type] "i" (READ_DATA));
  return 0;
}

xlen_t kill_transaction(tid_type tid) {
  return -1;
}
