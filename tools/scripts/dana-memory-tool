#!/usr/bin/python

import argparse
import re

def parse_arguments():
    parser = argparse.ArgumentParser(
        description='Tool to show the expected layout of memory for DANA')
    parser.add_argument(
        '-b', '--elements-per-block', dest='elementsPerBlock', type=int,
        required=True, help='The number of elements per block')
    parser.add_argument(
        '-l', '--learning-transaction', dest='learning_f', action='store_true',
        default=False, help='Print memory for a learning transaction')
    parser.add_argument(
        '-n', '--nn-config', dest='nnConfig', type=str,
        required=True, help='FANN neural network file to use for topology')
    return parser.parse_args()

class Memory:

    def __init__(self, layerArray, epb):
        self.addr = 0
        self.currentLayer = 0
        self.layerArray = layerArray
        self.epb = epb

    def __alignAddr(self):
        if (self.addr % self.epb != 0):
            self.addr = self.addr + int(self.epb - self.addr % self.epb)
            print("")

    def __printExpectedOut(self):
        print("E[out] ", end='')
        self.__printNeurons(self.layerArray[len(self.layerArray)-1])
        self.__alignAddr()

    def __printNeurons(self, layer):
        print("0x%x " % self.addr, end='')
        for neuron in range(layer - 1):
            print("%x " % self.addr, end='')
            if (self.addr % self.epb == self.epb - 1):
                print("")
            self.addr += 1
        self.__alignAddr()

    def __printDW(self):
        for layer in self.layerArray[1:len(self.layerArray)-1]:
            print("DW     ", end='')
            self.__printNeurons(layer)

    def __printBias(self):
        layerNumber = 1
        for layer in self.layerArray[1:len(self.layerArray)]:
            if (layerNumber == len(self.layerArray)-1):
                print("Bias[Out]  ", end='')
            else:
                print("Bias[H[%2d]] " % (layerNumber - 1), end='')
            layerNumber += 1
            self.__printNeurons(layer)

    def __printSlopes(self):
        for layerIndex in range(1, len(self.layerArray)):
            if (layerIndex == len(self.layerArray)-1):
                print("Slope[Out] ", end='')
            else:
                print("Slope[H[%2d]] " % (layerIndex - 1), end='')
            print("0x%x " % self.addr, end='')
            for neuron in range(self.layerArray[layerIndex] - 1):
                for neuron in range(self.layerArray[layerIndex - 1] - 1):
                    print("%x " % self.addr, end='')
                    if (self.addr % self.epb == self.epb - 1):
                        print("")
                    self.addr += 1
                self.__alignAddr()

    def printLearning(self):
        self.__printExpectedOut()
        self.printFeedforward()
        self.__printDW()
        self.__printBias()
        self.__printSlopes()

    def printFeedforward(self):
        layerNumber = 0
        for layer in self.layerArray:
            if (layerNumber == 0):
                print("In     ", end='')
            elif (layerNumber < len(self.layerArray) - 1):
                print("H[%2d]   " % (layerNumber - 1), end='')
            else:
                print("Out    ", end='')
            layerNumber += 1
            self.__printNeurons(layer)

def main():
    args = parse_arguments()

    with open(args.nnConfig, 'r') as f:
        reLayerSizes = re.compile('layer_sizes=([\d ]+)')
        for line in f:
            layerSearch = reLayerSizes.match(line)
            if layerSearch:
                layers = re.split(' ',layerSearch.group(1))
                break

    # Remove the trailing whitespace on the layer_sizes FANN line
    del(layers[len(layers) - 1])

    for i in range(len(layers)):
        layers[i] = int(layers[i])

    memory = Memory(layers, args.elementsPerBlock)
    if (args.learning_f):
        memory.printLearning()
    else:
        memory.printFeedforward()

if __name__ == '__main__':
    main()
